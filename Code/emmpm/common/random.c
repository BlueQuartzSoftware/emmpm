/* random.c */

/* random3(): modified on 10/23/89 from random2() to generate positive ints*/
/* Modified again on 9/4/06 by Joel Dumke for VS .NET */

/* #include<pwd.h> */
#include <stdio.h>
#include <stdlib.h>

#include <string.h>
#define MAXPRIME  2147483647       /*  MAXPRIME = (2^31)-1     */
#define PI        3.14159265358979323846

/* PORTABILITY 1:  The functions in this file assume that a long is 32 bits
      and a short is 16 bits.  These conventions are machine dependent and
      must therefore be verified before using.                     */


/**  emmpm_rnd_tmp: 31 bit seed in GF( (2^31)-1 )
* emmpm_seedBits[0]: high order 15 bits of emmpm_rnd_tmp
* emmpm_seedBits[1]: low order 16 bits of emmpm_rnd_tmp
* NOTE: high order 16 bits of emmpm_seedBits[0] and emmpm_seedBits[1] are 0
*/
static unsigned int   emmpm_seedBits[2],emmpm_rnd_tmp;


/** @brief Here is a portable C implementation of the ``minimal standard''
 * generator proposed by Park and Miller:
 */
#define PM_A 48271
#define PM_M 2147483647
#define PM_Q (PM_M / PM_A)
#define PM_R (PM_M % PM_A)

static long int seed = 1;

double park_miller_rng()
{
  long int hi = seed / PM_Q;
  long int lo = seed % PM_Q;
  long int test = PM_A * lo - PM_R * hi;
  if(test > 0)
    seed = test;
  else  seed = test + PM_M;
  return (double)seed / PM_M;
}






/* Generates 20 random #'s starting from a seed of 1  */
/*
main()
{
 int    i;
 int  r,random3();

 srandom2(1);
 for(i=0;i<20;i++) {
    r=random3();
    printf("%d\n",r);
 }
}
*/
/*  TABLE:  The following are the first 20 random #'s which should be generated
         starting from a seed of 1:

16807
282475249
1622650073
984943658
1144108930
470211272
101027544
1457850878
1458777923
2007237709
823564440
1115438165
1784484492
74243042
114807987
1137522503
1441282327
16531729
823378840
143542612
                                          */

/*  Test for verifying the cycle length of the random # generator  */
/*   NOTE:  to speed up this test, comment out the return statement
                               in random2()                        */
/*
main()
{
 double random2();
 int i;

 srandom2(1);
 tmp=0;
 while (tmp!=1) {
   for(i=0;i<(256*256*256);i++) {
       random2();
       if (tmp == 1) break;
   }
   printf("*\n");
   if (tmp == 0) break;
   writeseed();
 }
 printf("\n%d\n",i);
 writeseed();
}
*/

/* Uniform random number generator on (0,1] */
/*  Algorithm:  newseed = (16807 * oldseed) MOD [(2^31) - 1]  ;
                returned value = newseed / ( (2^31)-1 )  ;
      newseed is stored in tmp and sd[0] and sd[1] are updated;
      Since 16807 is a primitive element of GF[(2^31)-1], repeated calls
      to random2() should generate all positive integers <= MAXPRIME
      before repeating any one value.
    Tested: Feb. 16, 1988;  verified the length of cycle of integers
                             generated by repeated calls to random2()  */
double genrand_real2()
{
  *(emmpm_seedBits + 1) *= 16807;
  *emmpm_seedBits *= 16807;
  emmpm_rnd_tmp = ((*emmpm_seedBits) >> 15) + (((*emmpm_seedBits) & 0x7fff) << 16);
  emmpm_rnd_tmp += (*(emmpm_seedBits + 1));
  if (emmpm_rnd_tmp & 0x80000000)
  {
    emmpm_rnd_tmp++;
    emmpm_rnd_tmp &= 0x7fffffff;
  }
  *emmpm_seedBits = emmpm_rnd_tmp >> 16;
  *(emmpm_seedBits + 1) = emmpm_rnd_tmp & 0xffff;
  return (((double)emmpm_rnd_tmp) / MAXPRIME);
}


/* random3(): modified on 10/23/89 from random2() to generate positive ints*/
/* Uniform random number generator on (0,1] */
/*  Algorithm:  newseed = (16807 * oldseed) MOD [(2^31) - 1]  ;
                returned value = newseed / ( (2^31)-1 )  ;
      newseed is stored in tmp and sd[0] and sd[1] are updated;
      Since 16807 is a primitive element of GF[(2^31)-1], repeated calls
      to random2() should generate all positive integers <= MAXPRIME
      before repeating any one value.
    Tested: Feb. 16, 1988;  verified the length of cycle of integers
                             generated by repeated calls to random2()  */
int genrand_real3()
{
  *(emmpm_seedBits + 1) *= 16807;
  *emmpm_seedBits *= 16807;
  emmpm_rnd_tmp = ((*emmpm_seedBits) >> 15) + (((*emmpm_seedBits) & 0x7fff) << 16);
  emmpm_rnd_tmp += (*(emmpm_seedBits + 1));
  if (emmpm_rnd_tmp & 0x80000000)
  {
    emmpm_rnd_tmp++;
    emmpm_rnd_tmp &= 0x7fffffff;
  }
  *emmpm_seedBits = emmpm_rnd_tmp >> 16;
  *(emmpm_seedBits + 1) = emmpm_rnd_tmp & 0xffff;
  return ((int)emmpm_rnd_tmp);
}

/** @brief Set a new seed for random # generator  */
void init_genrand(unsigned long num)
{
 emmpm_rnd_tmp=num;
 *emmpm_seedBits=emmpm_rnd_tmp>>16;
 *(emmpm_seedBits+1)=emmpm_rnd_tmp & 0xffff;
}

/** @brief  Writes random # generator seed from file: /tmp/randomseedmlc */
void writeseed()
{
  printf("+ Writing Random Seed '%d' to file /tmp/randomseedmlc", emmpm_rnd_tmp);
  FILE* fp1;
  //char *calloc();
  fp1 = fopen("/tmp/randomseedmlc", "w");
  if ( NULL == fp1)
  {
    fprintf(stderr, "writeseed: can't open file /tmp/randomseedmlc\n");
    return;
  }
  else
  {
    fprintf(fp1, "%d", emmpm_rnd_tmp);
    fclose(fp1);
  }
}

/** @brief  Reads random # generator seed from file: /tmp/randomseedmlc */
void readseed()
{
  FILE* fp1;

  fp1 = fopen("/tmp/randomseedmlc", "r");
  if (NULL == fp1)
  {
    fprintf(stderr, "EMMPM.readseed():Could not read random seed file /tmp/randomseedmlc. Creating file\n");
    emmpm_rnd_tmp = 143542612;
    writeseed();
    init_genrand(emmpm_rnd_tmp);
  }
  else
  {
    fscanf(fp1, "%d", &emmpm_rnd_tmp);
    init_genrand(emmpm_rnd_tmp);
    fclose(fp1);
  }
}


/** @brief  Generates normal random numbers: N(0,1)  */
double normal()
{
  static int even = 1; /*   if  even = 0:  return b              */
  /*       even = 1:  compute 2 new values  */
  static double b; /*   temporary storage                    */
  double a, r, theta;

  if ((even = !even))
  {
    return (b);
  }
  else
  {
    theta = 2 * PI * genrand_real2();
    r = sqrt(-2 * log(genrand_real2()));
    a = r * cos(theta);
    b = r * sin(theta);
    return (a);
  }
}

/** @brief  Generates a double exponentially distributed random variable
      with mean 0 and variance 2.
*/
double dexprand()
{
  double a, genrand_real2();

  a = -log(genrand_real2());
  if (genrand_real2() > 0.5) a = (-a);
  return (a);
}




